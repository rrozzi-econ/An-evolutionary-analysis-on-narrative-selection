globals[
 omega
 omega_h
 p
 lambda
 avg_mu1
 avgmu_list
 std_mu1
 rho_1
 rho_2
 mu_0
 ps
 q
 diff_ps1
 diff_ps_aut
 diff_ps_bay
 diff_ps_conf
 diff_ps_antic
 diff_ps_anti_auto
 nconf
 nanticonf
 nbays
 nauto
 nanti_auto
 tau
 deaths
 avg_mu_bays
 avg_mu_conf
 avg_mu_anticonf
 avg_mu_auto
 avg_mu_antiau
]

breed [bayesians bayesian]
breed [autorefs autoref]
breed [confs conf]
breed [anticonfs anticonf]
breed [antiautos antiauto]

turtles-own[
 mu
 mu_t
 s ;0=a 1=b
 avg_mu
 fit
 rho
 diff_ps
]

to setup
  clear-all
  set p 0.75 ;+ random-float 0.5
  set lambda 5; random-float 5 ; lambda 5 should be big enough to make only the beliefs count
  set rho_1 0.6 ;+ random-float 0.5 ;same here (random)
  set rho_2 0.9 ;rho_1 + random-float (1 - rho_1)
  set ps 0.5
  set mu_0 0.5
  set tau 10
  ifelse random-float 1 <= ps
    [set omega 0]
    [set omega 1]
  set omega_h list omega omega_h
  set nconf random pop
  ;ifelse nconf < pop [set nbays pop - nconf] [set nbays 0]
  ifelse nconf < pop [set nanticonf random (pop - nconf)] [set nanticonf 0]
  ifelse nconf + nanticonf < pop [set nbays random (pop - nconf - nanticonf)] [set nbays 0]
  ifelse nconf + nanticonf + nbays < pop [set nauto random (pop - nconf - nanticonf - nbays)] [set nauto 0]
  ifelse nconf + nanticonf + nbays + nauto < pop [set nanti_auto pop - (nconf + nanticonf + nbays + nauto)] [set nanti_auto 0]
  create-confs nconf [
    move-to one-of patches ;meaningless
    set mu list mu_0 mu
  ]
  create-anticonfs nanticonf [
    move-to one-of patches ;meaningless
    set mu list mu_0 mu
  ]
  create-bayesians nbays [
    move-to one-of patches ;meaningless
    set mu list mu_0 mu
  ]
  create-autorefs nauto [
    move-to one-of patches ;meaningless
    set mu list mu_0 mu
  ]
  create-antiautos nanti_auto [
    move-to one-of patches
    set mu list mu_0 mu
  ]
  set avgmu_list list mu_0 avgmu_list
  reset-ticks
end

to go

  ifelse ticks = 0
  [set q 0.5]
  [set q 1 - (sum omega_h) / (length omega_h)]

  ifelse ticks = 0
    [set avg_mu1 mean [mu_0] of turtles
;     set avg_mu_bays mean [mu_0] of bayesians
;     set avg_mu_conf mean [mu_0] of confs
;     set avg_mu_anticonf mean [first mu] of anticonfs
;     set avg_mu_auto mean [first mu] of autorefs
;     set avg_mu_antiau mean [first mu] of antiautos
     set diff_ps1 mu_0 - ps
  ]
  [set avg_mu1 mean [first mu] of turtles
   set diff_ps1 mean [diff_ps] of turtles
   set avgmu_list fput avg_mu1 avgmu_list
;   set avg_mu_bays mean [first mu] of bayesians
;   set avg_mu_conf mean [first mu] of confs
;   set avg_mu_anticonf mean [first mu] of anticonfs
;   set avg_mu_auto mean [first mu] of autorefs
;   set avg_mu_antiau mean [first mu] of antiautos
  ]

  ifelse ticks = 0
    [set std_mu1 standard-deviation [mu_0] of turtles]
    [set std_mu1 standard-deviation [first mu] of turtles]

  ifelse ticks = 0
  [set omega first omega_h]
  [ifelse first omega_h = 0
    [ifelse random-float 1 <= (3 * ps - 1) / (2 * ps)
      [set omega 0
       set omega_h fput omega omega_h]
      [set omega 1
       set omega_h fput omega omega_h]
    ]
    [ifelse random-float 1 <= 0.5
      [set omega 1
       set omega_h fput omega omega_h]
      [set omega 0
       set omega_h fput omega omega_h]
    ]
  ]
  
ask bayesians [
    ifelse omega = 0
      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 0]
        [set s 1]
       ]

      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 1]
        [set s 0]
       ]

    BU

    ifelse ticks = 0
    [set mu fput mu_0 mu]
    [set mu fput mu_t mu]

    ifelse first mu < 0.5 [set color blue] [set color red]
    set diff_ps (first mu - ps) ^ 2
  ]

ask confs [
    ifelse omega = 0
      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 0]
        [set s 1]
       ]

      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 1]
        [set s 0]
       ]

    det-mu1
    ;conform

    ifelse ticks = 0
    [set mu fput mu_0 mu]
    [set mu fput mu_t mu]

    ifelse first mu < 0.5 [set color blue] [set color red]
    set diff_ps (first mu - ps) ^ 2
  ]

 ask anticonfs [
   ifelse omega = 0
      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 0]
        [set s 1]
       ]

      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 1]
        [set s 0]
       ]

    det-mu2

    ifelse ticks = 0
    [set mu fput mu_0 mu]
    [set mu fput mu_t mu]

    ifelse first mu < 0.5 [set color blue] [set color red]
    set diff_ps (first mu - ps) ^ 2
  ]

  ask autorefs [
    ifelse omega = 0
      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 0]
        [set s 1]
       ]

      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 1]
        [set s 0]
       ]

    det-fit

    ifelse ticks = 0
    [set mu fput mu_0 mu]
    [set mu fput mu_t mu]

    ifelse first mu < 0.5 [set color blue] [set color red]
    set diff_ps (first mu - ps) ^ 2
    ]

  ask antiautos [ifelse omega = 0
      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 0]
        [set s 1]
       ]

      [ifelse random-float 1 <= p ; random-float 1 returns a number between 0 and 1, if it is lower than p then agents receive signal a (so it's more likely they receive signal a since omega = A)
        [set s 1]
        [set s 0]
       ]

    det-anti_fit

    ifelse ticks = 0
    [set mu fput mu_0 mu]
    [set mu fput mu_t mu]

    ifelse first mu < 0.5 [set color blue] [set color red]
    set diff_ps (first mu - ps) ^ 2
  ]

  if ticks > 0 [
    if ticks mod tau = 0 [
      let dmin min [diff_ps] of turtles
      let dmax max [diff_ps] of turtles
      ask turtles [
        ifelse diff_ps <= diff_ps1 
        [if random-float 1 <= 0.5 * (diff_ps - dmin) / (diff_ps1 - dmin) [set deaths deaths + 1 die]]
        [if random-float 1 <= 0.5 * (1 + (diff_ps - diff_ps1) / (dmax - diff_ps1))  [set deaths deaths + 1 die]]
      ]
      ;; Compute how many new turtles we need
       let current-count count turtles
    let needed pop - current-count
    if needed < 0 [ set needed 0 ]  ;; just in case

    ;; Divide evenly among 5 or 2 breeds
     let per-breed floor (needed / 5)
     let rest needed - (5 * per-breed)
;     let per-breed floor (needed / 2)
;     let rest needed - (2 * per-breed)
    
    ;; Recreate new turtles
    create-confs per-breed [move-to one-of patches set mu_0 0.5 set mu list mu_0 mu]
    create-autorefs per-breed [move-to one-of patches set mu_0 0.5 set mu list mu_0 mu]
    create-antiautos per-breed [move-to one-of patches set mu_0 0.5 set mu list mu_0 mu]
    create-bayesians per-breed [move-to one-of patches set mu_0 0.5 set mu list mu_0 mu]
    create-anticonfs (per-breed + rest) [move-to one-of patches set mu_0 0.5 set mu list mu_0 mu]
    ;; rest goes to anticonfs, but you can change which breed gets it
    ]
  ]

  tick
end

to conform
  ifelse s = 0; s = a
   [set mu_t 0.5 * (p * (first mu)) / (p * (first mu) + (1 - p) * (1 - (first mu))) + 0.5 * (mean [mu_t] of bayesians)]
   [set mu_t 0.5 * ((1 - p) * (first mu))/((1 - p) * (first mu) + p * (1 - (first mu))) + 0.5 * (mean [mu_t] of bayesians)]
end

to BU ; standard bayesian updating
  ifelse s = 0; s = a
   [set mu_t (p * (first mu)) / (p * (first mu) + (1 - p) * (1 - (first mu)))]
   [set mu_t ((1 - p) * (first mu))/((1 - p) * (first mu) + p * (1 - (first mu)))]
end

to det-mu1 ; BU with conf

  ifelse s = 0; s = a
  [ifelse ((rho_1 * (first mu)) / (rho_1 * (first mu) + (1 - rho_1) * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2 < ( (rho_2 * (first mu)) / (rho_2 * (first mu) + (1 - rho_2) * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2
    [set rho rho_1
     set fit (first mu) * rho_1 + (1 - first mu) * (1 - rho_1)
     set mu_t (rho_1 * (first mu)) / (rho_1 * (first mu) + (1 - rho_1) * (1 - (first mu)))]
    [set rho rho_2
     set fit (first mu) * rho_2 + (1 - first mu) * (1 - rho_2)
     set mu_t (rho_2 * (first mu)) / (rho_2 * (first mu) + (1 - rho_2) * (1 - (first mu)))]
  ]
  [ifelse (((1 - rho_1) * (first mu))/((1 - rho_1) * (first mu) + rho_1 * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2 < (((1 - rho_2) * (first mu))/((1 - rho_2) * (first mu) + rho_2 * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2
    [set rho rho_1
     set fit (first mu) * (1 - rho_1) + (1 - first mu) * rho_1
     set mu_t ((1 - rho_1) * (first mu))/((1 - rho_1) * (first mu) + rho_1 * (1 - (first mu)))]
    [set rho rho_2
     set fit (first mu) * (1 - rho_2) + (1 - first mu) * rho_2
     set mu_t ((1 - rho_2) * (first mu))/((1 - rho_2) * (first mu) + rho_2 * (1 - (first mu)))]
  ]
end

to det-mu2 ; BU with anticonf

  ifelse s = 0; s = a
  [ifelse ((rho_1 * (first mu)) / (rho_1 * (first mu) + (1 - rho_1) * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2 > ( (rho_2 * (first mu)) / (rho_2 * (first mu) + (1 - rho_2) * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2
    [set rho rho_1
     set fit (first mu) * rho_1 + (1 - first mu) * (1 - rho_1)
     set mu_t (rho_1 * (first mu)) / (rho_1 * (first mu) + (1 - rho_1) * (1 - (first mu)))]
    [set rho rho_2
     set fit (first mu) * rho_2 + (1 - first mu) * (1 - rho_2)
     set mu_t (rho_2 * (first mu)) / (rho_2 * (first mu) + (1 - rho_2) * (1 - (first mu)))]
  ]
  [ifelse (((1 - rho_1) * (first mu))/((1 - rho_1) * (first mu) + rho_1 * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2 > (((1 - rho_2) * (first mu))/((1 - rho_2) * (first mu) + rho_2 * (1 - (first mu))) - (mean [first mu] of other turtles)) ^ 2
    [set rho rho_1
     set fit (first mu) * (1 - rho_1) + (1 - first mu) * rho_1
     set mu_t ((1 - rho_1) * (first mu))/((1 - rho_1) * (first mu) + rho_1 * (1 - (first mu)))]
    [set rho rho_2
     set fit (first mu) * (1 - rho_2) + (1 - first mu) * rho_2
     set mu_t ((1 - rho_2) * (first mu))/((1 - rho_2) * (first mu) + rho_2 * (1 - (first mu)))]
  ]
end

to det-fit ; fit

  ifelse s = 0; s = a
    [ifelse (first mu) * rho_1 + (1 - first mu) * (1 - rho_1) > (first mu) * rho_2 + (1 - first mu) * (1 - rho_2)
      [set mu_t (rho_1 * (first mu)) / (rho_1 * (first mu) + (1 - rho_1) * (1 - (first mu)))
       set rho rho_1
       set fit (first mu) * rho_1 + (1 - first mu) * (1 - rho_1)
       ]
      [set mu_t (rho_2 * (first mu)) / (rho_2 * (first mu) + (1 - rho_2) * (1 - (first mu)))
       set rho rho_2
       set fit (first mu) * rho_2 + (1 - first mu) * (1 - rho_2)
       ]
    ]
    [ifelse (first mu) * (1 - rho_1) + (1 - first mu) * rho_1 > (first mu) * (1 - rho_2) + (1 - first mu) * rho_2
      [set mu_t ((1 - rho_1) * (first mu))/((1 - rho_1) * (first mu) + rho_1 * (1 - (first mu)))
       set rho rho_1
       set fit (first mu) * (1 - rho_1) + (1 - first mu) * rho_1
       ]
      [set mu_t ((1 - rho_2) * (first mu))/((1 - rho_2) * (first mu) + rho_2 * (1 - (first mu)))
       set rho rho_2
       set fit (first mu) * (1 - rho_2) + (1 - first mu) * rho_2
       ]
    ]
end

to det-anti_fit ; fit

  ifelse s = 0; s = a
    [ifelse (first mu) * rho_1 + (1 - first mu) * (1 - rho_1) < (first mu) * rho_2 + (1 - first mu) * (1 - rho_2)
      [set mu_t (rho_1 * (first mu)) / (rho_1 * (first mu) + (1 - rho_1) * (1 - (first mu)))
       set rho rho_1
       set fit (first mu) * rho_1 + (1 - first mu) * (1 - rho_1)
       ]
      [set mu_t (rho_2 * (first mu)) / (rho_2 * (first mu) + (1 - rho_2) * (1 - (first mu)))
       set rho rho_2
       set fit (first mu) * rho_2 + (1 - first mu) * (1 - rho_2)
       ]
    ]
    [ifelse (first mu) * (1 - rho_1) + (1 - first mu) * rho_1 < (first mu) * (1 - rho_2) + (1 - first mu) * rho_2
      [set mu_t ((1 - rho_1) * (first mu))/((1 - rho_1) * (first mu) + rho_1 * (1 - (first mu)))
       set rho rho_1
       set fit (first mu) * (1 - rho_1) + (1 - first mu) * rho_1
       ]
      [set mu_t ((1 - rho_2) * (first mu))/((1 - rho_2) * (first mu) + rho_2 * (1 - (first mu)))
       set rho rho_2
       set fit (first mu) * (1 - rho_2) + (1 - first mu) * rho_2
       ]
    ]
end
